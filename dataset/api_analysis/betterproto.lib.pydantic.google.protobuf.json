[
  {
    "type": "class",
    "name": "betterproto.lib.pydantic.google.protobuf.Struct",
    "signature": "(*args: Any, fields: Dict[str, betterproto.lib.pydantic.google.protobuf.Value] = <object object at 0x101228be0>) -> None",
    "docstring": "`Struct` represents a structured data value, consisting of fields\n which map to dynamically typed values. In some languages, `Struct`\n might be supported by a native representation. For example, in\n scripting languages like JS a struct is represented as an\n object. The details of that representation are described together\n with the proto support for the language.\n\n The JSON representation for `Struct` is JSON object.",
    "source_code": "@dataclass(eq=False, repr=False)\nclass Struct(betterproto.Message):\n    \"\"\"\n    `Struct` represents a structured data value, consisting of fields\n     which map to dynamically typed values. In some languages, `Struct`\n     might be supported by a native representation. For example, in\n     scripting languages like JS a struct is represented as an\n     object. The details of that representation are described together\n     with the proto support for the language.\n\n     The JSON representation for `Struct` is JSON object.\n    \"\"\"\n\n    fields: Dict[str, \"Value\"] = betterproto.map_field(\n        1, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE\n    )\n    \"\"\"Unordered map of dynamically typed values.\"\"\"\n\n    @hybridmethod\n    def from_dict(cls: \"type[Self]\", value: Mapping[str, Any]) -> Self:  # type: ignore\n        self = cls()\n        return self.from_dict(value)\n\n    @from_dict.instancemethod\n    def from_dict(self, value: Mapping[str, Any]) -> Self:\n        fields = {**value}\n        for k in fields:\n            if hasattr(fields[k], \"from_dict\"):\n                fields[k] = fields[k].from_dict()\n\n        self.fields = fields\n        return self\n\n    def to_dict(\n        self,\n        casing: betterproto.Casing = betterproto.Casing.CAMEL,\n        include_default_values: bool = False,\n    ) -> Dict[str, Any]:\n        output = {**self.fields}\n        for k in self.fields:\n            if hasattr(self.fields[k], \"to_dict\"):\n                output[k] = self.fields[k].to_dict(casing, include_default_values)\n        return output\n",
    "methods": [
      {
        "name": "betterproto.lib.pydantic.google.protobuf.Struct.to_dict",
        "signature": "(self, casing: betterproto.Casing = <function camel_case at 0x10246b420>, include_default_values: bool = False) -> Dict[str, betterproto.lib.pydantic.google.protobuf.Any]",
        "docstring": "Returns a JSON serializable dict representation of this object.\n\nParameters\n-----------\ncasing: :class:`Casing`\n    The casing to use for key values. Default is :attr:`Casing.CAMEL` for\n    compatibility purposes.\ninclude_default_values: :class:`bool`\n    If ``True`` will include the default values of fields. Default is ``False``.\n    E.g. an ``int32`` field will be included with a value of ``0`` if this is\n    set to ``True``, otherwise this would be ignored.\n\nReturns\n--------\nDict[:class:`str`, Any]\n    The JSON serializable dict representation of this object.",
        "source_code": "    def to_dict(\n        self,\n        casing: betterproto.Casing = betterproto.Casing.CAMEL,\n        include_default_values: bool = False,\n    ) -> Dict[str, Any]:\n        output = {**self.fields}\n        for k in self.fields:\n            if hasattr(self.fields[k], \"to_dict\"):\n                output[k] = self.fields[k].to_dict(casing, include_default_values)\n        return output\n"
      }
    ]
  }
]