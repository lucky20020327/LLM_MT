[
  {
    "type": "class",
    "name": "betterproto.grpc.util.async_channel.AsyncChannel",
    "signature": "(*, buffer_limit: int = 0, close: bool = False)",
    "docstring": "A buffered async channel for sending items between coroutines with FIFO ordering.\n\nThis makes decoupled bidirectional steaming gRPC requests easy if used like:\n\n.. code-block:: python\n    client = GeneratedStub(grpclib_chan)\n    request_channel = await AsyncChannel()\n    # We can start be sending all the requests we already have\n    await request_channel.send_from([RequestObject(...), RequestObject(...)])\n    async for response in client.rpc_call(request_channel):\n        # The response iterator will remain active until the connection is closed\n        ...\n        # More items can be sent at any time\n        await request_channel.send(RequestObject(...))\n        ...\n        # The channel must be closed to complete the gRPC connection\n        request_channel.close()\n\nItems can be sent through the channel by either:\n- providing an iterable to the send_from method\n- passing them to the send method one at a time\n\nItems can be received from the channel by either:\n- iterating over the channel with a for loop to get all items\n- calling the receive method to get one item at a time\n\nIf the channel is empty then receivers will wait until either an item appears or the\nchannel is closed.\n\nOnce the channel is closed then subsequent attempt to send through the channel will\nfail with a ChannelClosed exception.\n\nWhen th channel is closed and empty then it is done, and further attempts to receive\nfrom it will fail with a ChannelDone exception\n\nIf multiple coroutines receive from the channel concurrently, each item sent will be\nreceived by only one of the receivers.\n\n:param source:\n    An optional iterable will items that should be sent through the channel\n    immediately.\n:param buffer_limit:\n    Limit the number of items that can be buffered in the channel, A value less than\n    1 implies no limit. If the channel is full then attempts to send more items will\n    result in the sender waiting until an item is received from the channel.\n:param close:\n    If set to True then the channel will automatically close after exhausting source\n    or immediately if no source is provided.",
    "source_code": "class AsyncChannel(AsyncIterable[T]):\n    \"\"\"\n    A buffered async channel for sending items between coroutines with FIFO ordering.\n\n    This makes decoupled bidirectional steaming gRPC requests easy if used like:\n\n    .. code-block:: python\n        client = GeneratedStub(grpclib_chan)\n        request_channel = await AsyncChannel()\n        # We can start be sending all the requests we already have\n        await request_channel.send_from([RequestObject(...), RequestObject(...)])\n        async for response in client.rpc_call(request_channel):\n            # The response iterator will remain active until the connection is closed\n            ...\n            # More items can be sent at any time\n            await request_channel.send(RequestObject(...))\n            ...\n            # The channel must be closed to complete the gRPC connection\n            request_channel.close()\n\n    Items can be sent through the channel by either:\n    - providing an iterable to the send_from method\n    - passing them to the send method one at a time\n\n    Items can be received from the channel by either:\n    - iterating over the channel with a for loop to get all items\n    - calling the receive method to get one item at a time\n\n    If the channel is empty then receivers will wait until either an item appears or the\n    channel is closed.\n\n    Once the channel is closed then subsequent attempt to send through the channel will\n    fail with a ChannelClosed exception.\n\n    When th channel is closed and empty then it is done, and further attempts to receive\n    from it will fail with a ChannelDone exception\n\n    If multiple coroutines receive from the channel concurrently, each item sent will be\n    received by only one of the receivers.\n\n    :param source:\n        An optional iterable will items that should be sent through the channel\n        immediately.\n    :param buffer_limit:\n        Limit the number of items that can be buffered in the channel, A value less than\n        1 implies no limit. If the channel is full then attempts to send more items will\n        result in the sender waiting until an item is received from the channel.\n    :param close:\n        If set to True then the channel will automatically close after exhausting source\n        or immediately if no source is provided.\n    \"\"\"\n\n    def __init__(self, *, buffer_limit: int = 0, close: bool = False):\n        self._queue: asyncio.Queue[T] = asyncio.Queue(buffer_limit)\n        self._closed = False\n        self._waiting_receivers: int = 0\n        # Track whether flush has been invoked so it can only happen once\n        self._flushed = False\n\n    def __aiter__(self) -> AsyncIterator[T]:\n        return self\n\n    async def __anext__(self) -> T:\n        if self.done():\n            raise StopAsyncIteration\n        self._waiting_receivers += 1\n        try:\n            result = await self._queue.get()\n            if result is self.__flush:\n                raise StopAsyncIteration\n            return result\n        finally:\n            self._waiting_receivers -= 1\n            self._queue.task_done()\n\n    def closed(self) -> bool:\n        \"\"\"\n        Returns True if this channel is closed and no-longer accepting new items\n        \"\"\"\n        return self._closed\n\n    def done(self) -> bool:\n        \"\"\"\n        Check if this channel is done.\n\n        :return: True if this channel is closed and and has been drained of items in\n        which case any further attempts to receive an item from this channel will raise\n        a ChannelDone exception.\n        \"\"\"\n        # After close the channel is not yet done until there is at least one waiting\n        # receiver per enqueued item.\n        return self._closed and self._queue.qsize() <= self._waiting_receivers\n\n    async def send_from(\n        self, source: Union[Iterable[T], AsyncIterable[T]], close: bool = False\n    ) -> \"AsyncChannel[T]\":\n        \"\"\"\n        Iterates the given [Async]Iterable and sends all the resulting items.\n        If close is set to True then subsequent send calls will be rejected with a\n        ChannelClosed exception.\n        :param source: an iterable of items to send\n        :param close:\n            if True then the channel will be closed after the source has been exhausted\n\n        \"\"\"\n        if self._closed:\n            raise ChannelClosed(\"Cannot send through a closed channel\")\n        if isinstance(source, AsyncIterable):\n            async for item in source:\n                await self._queue.put(item)\n        else:\n            for item in source:\n                await self._queue.put(item)\n        if close:\n            # Complete the closing process\n            self.close()\n        return self\n\n    async def send(self, item: T) -> \"AsyncChannel[T]\":\n        \"\"\"\n        Send a single item over this channel.\n        :param item: The item to send\n        \"\"\"\n        if self._closed:\n            raise ChannelClosed(\"Cannot send through a closed channel\")\n        await self._queue.put(item)\n        return self\n\n    async def receive(self) -> Optional[T]:\n        \"\"\"\n        Returns the next item from this channel when it becomes available,\n        or None if the channel is closed before another item is sent.\n        :return: An item from the channel\n        \"\"\"\n        if self.done():\n            raise ChannelDone(\"Cannot receive from a closed channel\")\n        self._waiting_receivers += 1\n        try:\n            result = await self._queue.get()\n            if result is self.__flush:\n                return None\n            return result\n        finally:\n            self._waiting_receivers -= 1\n            self._queue.task_done()\n\n    def close(self):\n        \"\"\"\n        Close this channel to new items\n        \"\"\"\n        self._closed = True\n        asyncio.ensure_future(self._flush_queue())\n\n    async def _flush_queue(self):\n        \"\"\"\n        To be called after the channel is closed. Pushes a number of self.__flush\n        objects to the queue to ensure no waiting consumers get deadlocked.\n        \"\"\"\n        if not self._flushed:\n            self._flushed = True\n            deadlocked_receivers = max(0, self._waiting_receivers - self._queue.qsize())\n            for _ in range(deadlocked_receivers):\n                await self._queue.put(self.__flush)\n\n    # A special signal object for flushing the queue when the channel is closed\n    __flush = object()\n",
    "methods": [
      {
        "name": "betterproto.grpc.util.async_channel.AsyncChannel.close",
        "signature": "(self)",
        "docstring": "Close this channel to new items",
        "source_code": "    def close(self):\n        \"\"\"\n        Close this channel to new items\n        \"\"\"\n        self._closed = True\n        asyncio.ensure_future(self._flush_queue())\n"
      },
      {
        "name": "betterproto.grpc.util.async_channel.AsyncChannel.closed",
        "signature": "(self) -> bool",
        "docstring": "Returns True if this channel is closed and no-longer accepting new items",
        "source_code": "    def closed(self) -> bool:\n        \"\"\"\n        Returns True if this channel is closed and no-longer accepting new items\n        \"\"\"\n        return self._closed\n"
      },
      {
        "name": "betterproto.grpc.util.async_channel.AsyncChannel.done",
        "signature": "(self) -> bool",
        "docstring": "Check if this channel is done.\n\n:return: True if this channel is closed and and has been drained of items in\nwhich case any further attempts to receive an item from this channel will raise\na ChannelDone exception.",
        "source_code": "    def done(self) -> bool:\n        \"\"\"\n        Check if this channel is done.\n\n        :return: True if this channel is closed and and has been drained of items in\n        which case any further attempts to receive an item from this channel will raise\n        a ChannelDone exception.\n        \"\"\"\n        # After close the channel is not yet done until there is at least one waiting\n        # receiver per enqueued item.\n        return self._closed and self._queue.qsize() <= self._waiting_receivers\n"
      },
      {
        "name": "betterproto.grpc.util.async_channel.AsyncChannel.receive",
        "signature": "(self) -> Optional[~T]",
        "docstring": "Returns the next item from this channel when it becomes available,\nor None if the channel is closed before another item is sent.\n:return: An item from the channel",
        "source_code": "    async def receive(self) -> Optional[T]:\n        \"\"\"\n        Returns the next item from this channel when it becomes available,\n        or None if the channel is closed before another item is sent.\n        :return: An item from the channel\n        \"\"\"\n        if self.done():\n            raise ChannelDone(\"Cannot receive from a closed channel\")\n        self._waiting_receivers += 1\n        try:\n            result = await self._queue.get()\n            if result is self.__flush:\n                return None\n            return result\n        finally:\n            self._waiting_receivers -= 1\n            self._queue.task_done()\n"
      },
      {
        "name": "betterproto.grpc.util.async_channel.AsyncChannel.send",
        "signature": "(self, item: ~T) -> 'AsyncChannel[T]'",
        "docstring": "Send a single item over this channel.\n:param item: The item to send",
        "source_code": "    async def send(self, item: T) -> \"AsyncChannel[T]\":\n        \"\"\"\n        Send a single item over this channel.\n        :param item: The item to send\n        \"\"\"\n        if self._closed:\n            raise ChannelClosed(\"Cannot send through a closed channel\")\n        await self._queue.put(item)\n        return self\n"
      },
      {
        "name": "betterproto.grpc.util.async_channel.AsyncChannel.send_from",
        "signature": "(self, source: Union[Iterable[~T], AsyncIterable[~T]], close: bool = False) -> 'AsyncChannel[T]'",
        "docstring": "Iterates the given [Async]Iterable and sends all the resulting items.\nIf close is set to True then subsequent send calls will be rejected with a\nChannelClosed exception.\n:param source: an iterable of items to send\n:param close:\n    if True then the channel will be closed after the source has been exhausted",
        "source_code": "    async def send_from(\n        self, source: Union[Iterable[T], AsyncIterable[T]], close: bool = False\n    ) -> \"AsyncChannel[T]\":\n        \"\"\"\n        Iterates the given [Async]Iterable and sends all the resulting items.\n        If close is set to True then subsequent send calls will be rejected with a\n        ChannelClosed exception.\n        :param source: an iterable of items to send\n        :param close:\n            if True then the channel will be closed after the source has been exhausted\n\n        \"\"\"\n        if self._closed:\n            raise ChannelClosed(\"Cannot send through a closed channel\")\n        if isinstance(source, AsyncIterable):\n            async for item in source:\n                await self._queue.put(item)\n        else:\n            for item in source:\n                await self._queue.put(item)\n        if close:\n            # Complete the closing process\n            self.close()\n        return self\n"
      }
    ]
  }
]