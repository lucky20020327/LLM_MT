[
  {
    "type": "class",
    "name": "typer.core.TyperCommand",
    "signature": "(name: Optional[str], *, context_settings: Optional[Dict[str, Any]] = None, callback: Optional[Callable[..., Any]] = None, params: Optional[List[click.core.Parameter]] = None, help: Optional[str] = None, epilog: Optional[str] = None, short_help: Optional[str] = None, options_metavar: Optional[str] = '[OPTIONS]', add_help_option: bool = True, no_args_is_help: bool = False, hidden: bool = False, deprecated: bool = False, rich_markup_mode: Literal['markdown', 'rich', None] = 'rich', rich_help_panel: Optional[str] = None) -> None",
    "docstring": "Commands are the basic building block of command line interfaces in\nClick.  A basic command handles command line parsing and might dispatch\nmore parsing to commands nested below it.\n\n:param name: the name of the command to use unless a group overrides it.\n:param context_settings: an optional dictionary with defaults that are\n                         passed to the context object.\n:param callback: the callback to invoke.  This is optional.\n:param params: the parameters to register with this command.  This can\n               be either :class:`Option` or :class:`Argument` objects.\n:param help: the help string to use for this command.\n:param epilog: like the help string but it's printed at the end of the\n               help page after everything else.\n:param short_help: the short help to use for this command.  This is\n                   shown on the command listing of the parent command.\n:param add_help_option: by default each command registers a ``--help``\n                        option.  This can be disabled by this parameter.\n:param no_args_is_help: this controls what happens if no arguments are\n                        provided.  This option is disabled by default.\n                        If enabled this will add ``--help`` as argument\n                        if no arguments are passed\n:param hidden: hide this command from help outputs.\n\n:param deprecated: issues a message indicating that\n                         the command is deprecated.\n\n.. versionchanged:: 8.1\n    ``help``, ``epilog``, and ``short_help`` are stored unprocessed,\n    all formatting is done when outputting help text, not at init,\n    and is done even if not using the ``@command`` decorator.\n\n.. versionchanged:: 8.0\n    Added a ``repr`` showing the command name.\n\n.. versionchanged:: 7.1\n    Added the ``no_args_is_help`` parameter.\n\n.. versionchanged:: 2.0\n    Added the ``context_settings`` parameter.",
    "source_code": "class TyperCommand(click.core.Command):\n    def __init__(\n        self,\n        name: Optional[str],\n        *,\n        context_settings: Optional[Dict[str, Any]] = None,\n        callback: Optional[Callable[..., Any]] = None,\n        params: Optional[List[click.Parameter]] = None,\n        help: Optional[str] = None,\n        epilog: Optional[str] = None,\n        short_help: Optional[str] = None,\n        options_metavar: Optional[str] = \"[OPTIONS]\",\n        add_help_option: bool = True,\n        no_args_is_help: bool = False,\n        hidden: bool = False,\n        deprecated: bool = False,\n        # Rich settings\n        rich_markup_mode: MarkupMode = DEFAULT_MARKUP_MODE,\n        rich_help_panel: Union[str, None] = None,\n    ) -> None:\n        super().__init__(\n            name=name,\n            context_settings=context_settings,\n            callback=callback,\n            params=params,\n            help=help,\n            epilog=epilog,\n            short_help=short_help,\n            options_metavar=options_metavar,\n            add_help_option=add_help_option,\n            no_args_is_help=no_args_is_help,\n            hidden=hidden,\n            deprecated=deprecated,\n        )\n        self.rich_markup_mode: MarkupMode = rich_markup_mode\n        self.rich_help_panel = rich_help_panel\n\n    def format_options(\n        self, ctx: click.Context, formatter: click.HelpFormatter\n    ) -> None:\n        _typer_format_options(self, ctx=ctx, formatter=formatter)\n\n    def _main_shell_completion(\n        self,\n        ctx_args: MutableMapping[str, Any],\n        prog_name: str,\n        complete_var: Optional[str] = None,\n    ) -> None:\n        _typer_main_shell_completion(\n            self, ctx_args=ctx_args, prog_name=prog_name, complete_var=complete_var\n        )\n\n    def main(\n        self,\n        args: Optional[Sequence[str]] = None,\n        prog_name: Optional[str] = None,\n        complete_var: Optional[str] = None,\n        standalone_mode: bool = True,\n        windows_expand_args: bool = True,\n        **extra: Any,\n    ) -> Any:\n        return _main(\n            self,\n            args=args,\n            prog_name=prog_name,\n            complete_var=complete_var,\n            standalone_mode=standalone_mode,\n            windows_expand_args=windows_expand_args,\n            rich_markup_mode=self.rich_markup_mode,\n            **extra,\n        )\n\n    def format_help(self, ctx: click.Context, formatter: click.HelpFormatter) -> None:\n        if not rich or self.rich_markup_mode is None:\n            return super().format_help(ctx, formatter)\n        return rich_utils.rich_format_help(\n            obj=self,\n            ctx=ctx,\n            markup_mode=self.rich_markup_mode,\n        )\n",
    "methods": [
      {
        "name": "typer.core.TyperCommand.format_help",
        "signature": "(self, ctx: click.core.Context, formatter: click.formatting.HelpFormatter) -> None",
        "docstring": "Writes the help into the formatter if it exists.\n\nThis is a low-level method called by :meth:`get_help`.\n\nThis calls the following methods:\n\n-   :meth:`format_usage`\n-   :meth:`format_help_text`\n-   :meth:`format_options`\n-   :meth:`format_epilog`",
        "source_code": "    def format_help(self, ctx: click.Context, formatter: click.HelpFormatter) -> None:\n        if not rich or self.rich_markup_mode is None:\n            return super().format_help(ctx, formatter)\n        return rich_utils.rich_format_help(\n            obj=self,\n            ctx=ctx,\n            markup_mode=self.rich_markup_mode,\n        )\n"
      },
      {
        "name": "typer.core.TyperCommand.format_options",
        "signature": "(self, ctx: click.core.Context, formatter: click.formatting.HelpFormatter) -> None",
        "docstring": "Writes all the options into the formatter if they exist.",
        "source_code": "    def format_options(\n        self, ctx: click.Context, formatter: click.HelpFormatter\n    ) -> None:\n        _typer_format_options(self, ctx=ctx, formatter=formatter)\n"
      }
    ]
  },
  {
    "type": "class",
    "name": "typer.core.TyperGroup",
    "signature": "(*, name: Optional[str] = None, commands: Union[Dict[str, click.core.Command], Sequence[click.core.Command], NoneType] = None, rich_markup_mode: Literal['markdown', 'rich', None] = 'rich', rich_help_panel: Optional[str] = None, **attrs: Any) -> None",
    "docstring": "A group allows a command to have subcommands attached. This is\nthe most common way to implement nesting in Click.\n\n:param name: The name of the group command.\n:param commands: A dict mapping names to :class:`Command` objects.\n    Can also be a list of :class:`Command`, which will use\n    :attr:`Command.name` to create the dict.\n:param attrs: Other command arguments described in\n    :class:`MultiCommand`, :class:`Command`, and\n    :class:`BaseCommand`.\n\n.. versionchanged:: 8.0\n    The ``commands`` argument can be a list of command objects.",
    "source_code": "class TyperGroup(click.core.Group):\n    def __init__(\n        self,\n        *,\n        name: Optional[str] = None,\n        commands: Optional[\n            Union[Dict[str, click.Command], Sequence[click.Command]]\n        ] = None,\n        # Rich settings\n        rich_markup_mode: MarkupMode = DEFAULT_MARKUP_MODE,\n        rich_help_panel: Union[str, None] = None,\n        **attrs: Any,\n    ) -> None:\n        super().__init__(name=name, commands=commands, **attrs)\n        self.rich_markup_mode: MarkupMode = rich_markup_mode\n        self.rich_help_panel = rich_help_panel\n\n    def format_options(\n        self, ctx: click.Context, formatter: click.HelpFormatter\n    ) -> None:\n        _typer_format_options(self, ctx=ctx, formatter=formatter)\n        self.format_commands(ctx, formatter)\n\n    def _main_shell_completion(\n        self,\n        ctx_args: MutableMapping[str, Any],\n        prog_name: str,\n        complete_var: Optional[str] = None,\n    ) -> None:\n        _typer_main_shell_completion(\n            self, ctx_args=ctx_args, prog_name=prog_name, complete_var=complete_var\n        )\n\n    def main(\n        self,\n        args: Optional[Sequence[str]] = None,\n        prog_name: Optional[str] = None,\n        complete_var: Optional[str] = None,\n        standalone_mode: bool = True,\n        windows_expand_args: bool = True,\n        **extra: Any,\n    ) -> Any:\n        return _main(\n            self,\n            args=args,\n            prog_name=prog_name,\n            complete_var=complete_var,\n            standalone_mode=standalone_mode,\n            windows_expand_args=windows_expand_args,\n            rich_markup_mode=self.rich_markup_mode,\n            **extra,\n        )\n\n    def format_help(self, ctx: click.Context, formatter: click.HelpFormatter) -> None:\n        if not rich or self.rich_markup_mode is None:\n            return super().format_help(ctx, formatter)\n        return rich_utils.rich_format_help(\n            obj=self,\n            ctx=ctx,\n            markup_mode=self.rich_markup_mode,\n        )\n\n    def list_commands(self, ctx: click.Context) -> List[str]:\n        \"\"\"Returns a list of subcommand names.\n        Note that in Click's Group class, these are sorted.\n        In Typer, we wish to maintain the original order of creation (cf Issue #933)\"\"\"\n        return [n for n, c in self.commands.items()]\n",
    "methods": [
      {
        "name": "typer.core.TyperGroup.format_help",
        "signature": "(self, ctx: click.core.Context, formatter: click.formatting.HelpFormatter) -> None",
        "docstring": "Writes the help into the formatter if it exists.\n\nThis is a low-level method called by :meth:`get_help`.\n\nThis calls the following methods:\n\n-   :meth:`format_usage`\n-   :meth:`format_help_text`\n-   :meth:`format_options`\n-   :meth:`format_epilog`",
        "source_code": "    def format_help(self, ctx: click.Context, formatter: click.HelpFormatter) -> None:\n        if not rich or self.rich_markup_mode is None:\n            return super().format_help(ctx, formatter)\n        return rich_utils.rich_format_help(\n            obj=self,\n            ctx=ctx,\n            markup_mode=self.rich_markup_mode,\n        )\n"
      },
      {
        "name": "typer.core.TyperGroup.format_options",
        "signature": "(self, ctx: click.core.Context, formatter: click.formatting.HelpFormatter) -> None",
        "docstring": "Writes all the options into the formatter if they exist.",
        "source_code": "    def format_options(\n        self, ctx: click.Context, formatter: click.HelpFormatter\n    ) -> None:\n        _typer_format_options(self, ctx=ctx, formatter=formatter)\n        self.format_commands(ctx, formatter)\n"
      },
      {
        "name": "typer.core.TyperGroup.list_commands",
        "signature": "(self, ctx: click.core.Context) -> List[str]",
        "docstring": "Returns a list of subcommand names.\nNote that in Click's Group class, these are sorted.\nIn Typer, we wish to maintain the original order of creation (cf Issue #933)",
        "source_code": "    def list_commands(self, ctx: click.Context) -> List[str]:\n        \"\"\"Returns a list of subcommand names.\n        Note that in Click's Group class, these are sorted.\n        In Typer, we wish to maintain the original order of creation (cf Issue #933)\"\"\"\n        return [n for n, c in self.commands.items()]\n"
      }
    ]
  }
]