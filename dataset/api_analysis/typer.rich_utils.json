[
  {
    "type": "function",
    "name": "typer.rich_utils.rich_abort_error",
    "signature": "() -> None",
    "docstring": "Print richly formatted abort error.",
    "source_code": "def rich_abort_error() -> None:\n    \"\"\"Print richly formatted abort error.\"\"\"\n    console = _get_rich_console(stderr=True)\n    console.print(ABORTED_TEXT, style=STYLE_ABORTED)\n",
    "methods": []
  },
  {
    "type": "function",
    "name": "typer.rich_utils.rich_format_error",
    "signature": "(self: click.exceptions.ClickException) -> None",
    "docstring": "Print richly formatted click errors.\n\nCalled by custom exception handler to print richly formatted click errors.\nMimics original click.ClickException.echo() function but with rich formatting.",
    "source_code": "def rich_format_error(self: click.ClickException) -> None:\n    \"\"\"Print richly formatted click errors.\n\n    Called by custom exception handler to print richly formatted click errors.\n    Mimics original click.ClickException.echo() function but with rich formatting.\n    \"\"\"\n    console = _get_rich_console(stderr=True)\n    ctx: Union[click.Context, None] = getattr(self, \"ctx\", None)\n    if ctx is not None:\n        console.print(ctx.get_usage())\n\n    if ctx is not None and ctx.command.get_help_option(ctx) is not None:\n        console.print(\n            RICH_HELP.format(\n                command_path=ctx.command_path, help_option=ctx.help_option_names[0]\n            ),\n            style=STYLE_ERRORS_SUGGESTION,\n        )\n\n    console.print(\n        Panel(\n            highlighter(self.format_message()),\n            border_style=STYLE_ERRORS_PANEL_BORDER,\n            title=ERRORS_PANEL_TITLE,\n            title_align=ALIGN_ERRORS_PANEL,\n        )\n    )\n",
    "methods": []
  },
  {
    "type": "function",
    "name": "typer.rich_utils.rich_format_help",
    "signature": "(*, obj: Union[click.core.Command, click.core.Group], ctx: click.core.Context, markup_mode: Literal['markdown', 'rich', None]) -> None",
    "docstring": "Print nicely formatted help text using rich.\n\nBased on original code from rich-cli, by @willmcgugan.\nhttps://github.com/Textualize/rich-cli/blob/8a2767c7a340715fc6fbf4930ace717b9b2fc5e5/src/rich_cli/__main__.py#L162-L236\n\nReplacement for the click function format_help().\nTakes a command or group and builds the help text output.",
    "source_code": "def rich_format_help(\n    *,\n    obj: Union[click.Command, click.Group],\n    ctx: click.Context,\n    markup_mode: MarkupMode,\n) -> None:\n    \"\"\"Print nicely formatted help text using rich.\n\n    Based on original code from rich-cli, by @willmcgugan.\n    https://github.com/Textualize/rich-cli/blob/8a2767c7a340715fc6fbf4930ace717b9b2fc5e5/src/rich_cli/__main__.py#L162-L236\n\n    Replacement for the click function format_help().\n    Takes a command or group and builds the help text output.\n    \"\"\"\n    console = _get_rich_console()\n\n    # Print usage\n    console.print(\n        Padding(highlighter(obj.get_usage(ctx)), 1), style=STYLE_USAGE_COMMAND\n    )\n\n    # Print command / group help if we have some\n    if obj.help:\n        # Print with some padding\n        console.print(\n            Padding(\n                Align(\n                    _get_help_text(\n                        obj=obj,\n                        markup_mode=markup_mode,\n                    ),\n                    pad=False,\n                ),\n                (0, 1, 1, 1),\n            )\n        )\n    panel_to_arguments: DefaultDict[str, List[click.Argument]] = defaultdict(list)\n    panel_to_options: DefaultDict[str, List[click.Option]] = defaultdict(list)\n    for param in obj.get_params(ctx):\n        # Skip if option is hidden\n        if getattr(param, \"hidden\", False):\n            continue\n        if isinstance(param, click.Argument):\n            panel_name = (\n                getattr(param, _RICH_HELP_PANEL_NAME, None) or ARGUMENTS_PANEL_TITLE\n            )\n            panel_to_arguments[panel_name].append(param)\n        elif isinstance(param, click.Option):\n            panel_name = (\n                getattr(param, _RICH_HELP_PANEL_NAME, None) or OPTIONS_PANEL_TITLE\n            )\n            panel_to_options[panel_name].append(param)\n    default_arguments = panel_to_arguments.get(ARGUMENTS_PANEL_TITLE, [])\n    _print_options_panel(\n        name=ARGUMENTS_PANEL_TITLE,\n        params=default_arguments,\n        ctx=ctx,\n        markup_mode=markup_mode,\n        console=console,\n    )\n    for panel_name, arguments in panel_to_arguments.items():\n        if panel_name == ARGUMENTS_PANEL_TITLE:\n            # Already printed above\n            continue\n        _print_options_panel(\n            name=panel_name,\n            params=arguments,\n            ctx=ctx,\n            markup_mode=markup_mode,\n            console=console,\n        )\n    default_options = panel_to_options.get(OPTIONS_PANEL_TITLE, [])\n    _print_options_panel(\n        name=OPTIONS_PANEL_TITLE,\n        params=default_options,\n        ctx=ctx,\n        markup_mode=markup_mode,\n        console=console,\n    )\n    for panel_name, options in panel_to_options.items():\n        if panel_name == OPTIONS_PANEL_TITLE:\n            # Already printed above\n            continue\n        _print_options_panel(\n            name=panel_name,\n            params=options,\n            ctx=ctx,\n            markup_mode=markup_mode,\n            console=console,\n        )\n\n    if isinstance(obj, click.Group):\n        panel_to_commands: DefaultDict[str, List[click.Command]] = defaultdict(list)\n        for command_name in obj.list_commands(ctx):\n            command = obj.get_command(ctx, command_name)\n            if command and not command.hidden:\n                panel_name = (\n                    getattr(command, _RICH_HELP_PANEL_NAME, None)\n                    or COMMANDS_PANEL_TITLE\n                )\n                panel_to_commands[panel_name].append(command)\n\n        # Identify the longest command name in all panels\n        max_cmd_len = max(\n            [\n                len(command.name or \"\")\n                for commands in panel_to_commands.values()\n                for command in commands\n            ],\n            default=0,\n        )\n\n        # Print each command group panel\n        default_commands = panel_to_commands.get(COMMANDS_PANEL_TITLE, [])\n        _print_commands_panel(\n            name=COMMANDS_PANEL_TITLE,\n            commands=default_commands,\n            markup_mode=markup_mode,\n            console=console,\n            cmd_len=max_cmd_len,\n        )\n        for panel_name, commands in panel_to_commands.items():\n            if panel_name == COMMANDS_PANEL_TITLE:\n                # Already printed above\n                continue\n            _print_commands_panel(\n                name=panel_name,\n                commands=commands,\n                markup_mode=markup_mode,\n                console=console,\n                cmd_len=max_cmd_len,\n            )\n\n    # Epilogue if we have it\n    if obj.epilog:\n        # Remove single linebreaks, replace double with single\n        lines = obj.epilog.split(\"\\n\\n\")\n        epilogue = \"\\n\".join([x.replace(\"\\n\", \" \").strip() for x in lines])\n        epilogue_text = _make_rich_text(text=epilogue, markup_mode=markup_mode)\n        console.print(Padding(Align(epilogue_text, pad=False), 1))\n",
    "methods": []
  },
  {
    "type": "function",
    "name": "typer.rich_utils.rich_render_text",
    "signature": "(text: str) -> str",
    "docstring": "Remove rich tags and render a pure text representation",
    "source_code": "def rich_render_text(text: str) -> str:\n    \"\"\"Remove rich tags and render a pure text representation\"\"\"\n    console = _get_rich_console()\n    return \"\".join(segment.text for segment in console.render(text)).rstrip(\"\\n\")\n",
    "methods": []
  },
  {
    "type": "function",
    "name": "typer.rich_utils.rich_to_html",
    "signature": "(input_text: str) -> str",
    "docstring": "Print the HTML version of a rich-formatted input string.\n\nThis function does not provide a full HTML page, but can be used to insert\nHTML-formatted text spans into a markdown file.",
    "source_code": "def rich_to_html(input_text: str) -> str:\n    \"\"\"Print the HTML version of a rich-formatted input string.\n\n    This function does not provide a full HTML page, but can be used to insert\n    HTML-formatted text spans into a markdown file.\n    \"\"\"\n    console = Console(record=True, highlight=False, file=io.StringIO())\n\n    console.print(input_text, overflow=\"ignore\", crop=False)\n\n    return console.export_html(inline_styles=True, code_format=\"{code}\").strip()\n",
    "methods": []
  }
]