[
  {
    "type": "class",
    "name": "betterproto.plugin.models.FieldCompiler",
    "signature": "(source_file: betterproto.lib.std.google.protobuf.FileDescriptorProto, typing_compiler: betterproto.plugin.typing_compiler.TypingCompiler, parent: betterproto.plugin.models.MessageCompiler = <object object at 0x101228e80>, proto_obj: betterproto.lib.std.google.protobuf.FieldDescriptorProto = <object object at 0x101228e80>, path: List[int] = <object object at 0x101228e80>, fields: List[Union[ForwardRef('FieldCompiler'), ForwardRef('MessageCompiler')]] = <factory>, builtins_types: Set[str] = <factory>) -> None",
    "docstring": "FieldCompiler(source_file: betterproto.lib.std.google.protobuf.FileDescriptorProto, typing_compiler: betterproto.plugin.typing_compiler.TypingCompiler, parent: betterproto.plugin.models.MessageCompiler = <object object at 0x101228e80>, proto_obj: betterproto.lib.std.google.protobuf.FieldDescriptorProto = <object object at 0x101228e80>, path: List[int] = <object object at 0x101228e80>, fields: List[Union[ForwardRef('FieldCompiler'), ForwardRef('MessageCompiler')]] = <factory>, builtins_types: Set[str] = <factory>)",
    "source_code": "@dataclass\nclass FieldCompiler(MessageCompiler):\n    parent: MessageCompiler = PLACEHOLDER\n    proto_obj: FieldDescriptorProto = PLACEHOLDER\n\n    def __post_init__(self) -> None:\n        # Add field to message\n        self.parent.fields.append(self)\n        # Check for new imports\n        self.add_imports_to(self.output_file)\n        super().__post_init__()  # call FieldCompiler-> MessageCompiler __post_init__\n\n    def get_field_string(self, indent: int = 4) -> str:\n        \"\"\"Construct string representation of this field as a field.\"\"\"\n        name = f\"{self.py_name}\"\n        annotations = f\": {self.annotation}\"\n        field_args = \", \".join(\n            ([\"\"] + self.betterproto_field_args) if self.betterproto_field_args else []\n        )\n        betterproto_field_type = (\n            f\"betterproto.{self.field_type}_field({self.proto_obj.number}{field_args})\"\n        )\n        if self.py_name in dir(builtins):\n            self.parent.builtins_types.add(self.py_name)\n        return f\"{name}{annotations} = {betterproto_field_type}\"\n\n    @property\n    def betterproto_field_args(self) -> List[str]:\n        args = []\n        if self.field_wraps:\n            args.append(f\"wraps={self.field_wraps}\")\n        if self.optional:\n            args.append(f\"optional=True\")\n        return args\n\n    @property\n    def datetime_imports(self) -> Set[str]:\n        imports = set()\n        annotation = self.annotation\n        # FIXME: false positives - e.g. `MyDatetimedelta`\n        if \"timedelta\" in annotation:\n            imports.add(\"timedelta\")\n        if \"datetime\" in annotation:\n            imports.add(\"datetime\")\n        return imports\n\n    @property\n    def pydantic_imports(self) -> Set[str]:\n        return set()\n\n    @property\n    def use_builtins(self) -> bool:\n        return self.py_type in self.parent.builtins_types or (\n            self.py_type == self.py_name and self.py_name in dir(builtins)\n        )\n\n    def add_imports_to(self, output_file: OutputTemplate) -> None:\n        output_file.datetime_imports.update(self.datetime_imports)\n        output_file.pydantic_imports.update(self.pydantic_imports)\n        output_file.builtins_import = output_file.builtins_import or self.use_builtins\n\n    @property\n    def field_wraps(self) -> Optional[str]:\n        \"\"\"Returns betterproto wrapped field type or None.\"\"\"\n        match_wrapper = re.match(\n            r\"\\.google\\.protobuf\\.(.+)Value$\", self.proto_obj.type_name\n        )\n        if match_wrapper:\n            wrapped_type = \"TYPE_\" + match_wrapper.group(1).upper()\n            if hasattr(betterproto, wrapped_type):\n                return f\"betterproto.{wrapped_type}\"\n        return None\n\n    @property\n    def repeated(self) -> bool:\n        return (\n            self.proto_obj.label == FieldDescriptorProtoLabel.LABEL_REPEATED\n            and not is_map(self.proto_obj, self.parent)\n        )\n\n    @property\n    def optional(self) -> bool:\n        return self.proto_obj.proto3_optional\n\n    @property\n    def mutable(self) -> bool:\n        \"\"\"True if the field is a mutable type, otherwise False.\"\"\"\n        return self.annotation.startswith(\n            (\"typing.List[\", \"typing.Dict[\", \"dict[\", \"list[\", \"Dict[\", \"List[\")\n        )\n\n    @property\n    def field_type(self) -> str:\n        \"\"\"String representation of proto field type.\"\"\"\n        return (\n            FieldDescriptorProtoType(self.proto_obj.type)\n            .name.lower()\n            .replace(\"type_\", \"\")\n        )\n\n    @property\n    def default_value_string(self) -> str:\n        \"\"\"Python representation of the default proto value.\"\"\"\n        if self.repeated:\n            return \"[]\"\n        if self.optional:\n            return \"None\"\n        if self.py_type == \"int\":\n            return \"0\"\n        if self.py_type == \"float\":\n            return \"0.0\"\n        elif self.py_type == \"bool\":\n            return \"False\"\n        elif self.py_type == \"str\":\n            return '\"\"'\n        elif self.py_type == \"bytes\":\n            return 'b\"\"'\n        elif self.field_type == \"enum\":\n            enum_proto_obj_name = self.proto_obj.type_name.split(\".\").pop()\n            enum = next(\n                e\n                for e in self.output_file.enums\n                if e.proto_obj.name == enum_proto_obj_name\n            )\n            return enum.default_value_string\n        else:\n            # Message type\n            return \"None\"\n\n    @property\n    def packed(self) -> bool:\n        \"\"\"True if the wire representation is a packed format.\"\"\"\n        return self.repeated and self.proto_obj.type in PROTO_PACKED_TYPES\n\n    @property\n    def py_name(self) -> str:\n        \"\"\"Pythonized name.\"\"\"\n        return pythonize_field_name(self.proto_name)\n\n    @property\n    def proto_name(self) -> str:\n        \"\"\"Original protobuf name.\"\"\"\n        return self.proto_obj.name\n\n    @property\n    def py_type(self) -> str:\n        \"\"\"String representation of Python type.\"\"\"\n        if self.proto_obj.type in PROTO_FLOAT_TYPES:\n            return \"float\"\n        elif self.proto_obj.type in PROTO_INT_TYPES:\n            return \"int\"\n        elif self.proto_obj.type in PROTO_BOOL_TYPES:\n            return \"bool\"\n        elif self.proto_obj.type in PROTO_STR_TYPES:\n            return \"str\"\n        elif self.proto_obj.type in PROTO_BYTES_TYPES:\n            return \"bytes\"\n        elif self.proto_obj.type in PROTO_MESSAGE_TYPES:\n            # Type referencing another defined Message or a named enum\n            return get_type_reference(\n                package=self.output_file.package,\n                imports=self.output_file.imports,\n                source_type=self.proto_obj.type_name,\n                typing_compiler=self.typing_compiler,\n                pydantic=self.output_file.pydantic_dataclasses,\n            )\n        else:\n            raise NotImplementedError(f\"Unknown type {self.proto_obj.type}\")\n\n    @property\n    def annotation(self) -> str:\n        py_type = self.py_type\n        if self.use_builtins:\n            py_type = f\"builtins.{py_type}\"\n        if self.repeated:\n            return self.typing_compiler.list(py_type)\n        if self.optional:\n            return self.typing_compiler.optional(py_type)\n        return py_type\n",
    "methods": [
      {
        "name": "betterproto.plugin.models.FieldCompiler.get_field_string",
        "signature": "(self, indent: int = 4) -> str",
        "docstring": "Construct string representation of this field as a field.",
        "source_code": "    def get_field_string(self, indent: int = 4) -> str:\n        \"\"\"Construct string representation of this field as a field.\"\"\"\n        name = f\"{self.py_name}\"\n        annotations = f\": {self.annotation}\"\n        field_args = \", \".join(\n            ([\"\"] + self.betterproto_field_args) if self.betterproto_field_args else []\n        )\n        betterproto_field_type = (\n            f\"betterproto.{self.field_type}_field({self.proto_obj.number}{field_args})\"\n        )\n        if self.py_name in dir(builtins):\n            self.parent.builtins_types.add(self.py_name)\n        return f\"{name}{annotations} = {betterproto_field_type}\"\n"
      }
    ]
  },
  {
    "type": "class",
    "name": "betterproto.plugin.models.MapEntryCompiler",
    "signature": "(source_file: betterproto.lib.std.google.protobuf.FileDescriptorProto, typing_compiler: betterproto.plugin.typing_compiler.TypingCompiler, parent: betterproto.plugin.models.MessageCompiler = <object object at 0x101228e80>, proto_obj: betterproto.lib.std.google.protobuf.FieldDescriptorProto = <object object at 0x101228e80>, path: List[int] = <object object at 0x101228e80>, fields: List[Union[ForwardRef('FieldCompiler'), ForwardRef('MessageCompiler')]] = <factory>, builtins_types: Set[str] = <factory>, py_k_type: Type = <object object at 0x101228e80>, py_v_type: Type = <object object at 0x101228e80>, proto_k_type: str = <object object at 0x101228e80>, proto_v_type: str = <object object at 0x101228e80>) -> None",
    "docstring": "MapEntryCompiler(source_file: betterproto.lib.std.google.protobuf.FileDescriptorProto, typing_compiler: betterproto.plugin.typing_compiler.TypingCompiler, parent: betterproto.plugin.models.MessageCompiler = <object object at 0x101228e80>, proto_obj: betterproto.lib.std.google.protobuf.FieldDescriptorProto = <object object at 0x101228e80>, path: List[int] = <object object at 0x101228e80>, fields: List[Union[ForwardRef('FieldCompiler'), ForwardRef('MessageCompiler')]] = <factory>, builtins_types: Set[str] = <factory>, py_k_type: Type = <object object at 0x101228e80>, py_v_type: Type = <object object at 0x101228e80>, proto_k_type: str = <object object at 0x101228e80>, proto_v_type: str = <object object at 0x101228e80>)",
    "source_code": "@dataclass\nclass MapEntryCompiler(FieldCompiler):\n    py_k_type: Type = PLACEHOLDER\n    py_v_type: Type = PLACEHOLDER\n    proto_k_type: str = PLACEHOLDER\n    proto_v_type: str = PLACEHOLDER\n\n    def __post_init__(self) -> None:\n        \"\"\"Explore nested types and set k_type and v_type if unset.\"\"\"\n        map_entry = f\"{self.proto_obj.name.replace('_', '').lower()}entry\"\n        for nested in self.parent.proto_obj.nested_type:\n            if (\n                nested.name.replace(\"_\", \"\").lower() == map_entry\n                and nested.options.map_entry\n            ):\n                # Get Python types\n                self.py_k_type = FieldCompiler(\n                    source_file=self.source_file,\n                    parent=self,\n                    proto_obj=nested.field[0],  # key\n                    typing_compiler=self.typing_compiler,\n                ).py_type\n                self.py_v_type = FieldCompiler(\n                    source_file=self.source_file,\n                    parent=self,\n                    proto_obj=nested.field[1],  # value\n                    typing_compiler=self.typing_compiler,\n                ).py_type\n\n                # Get proto types\n                self.proto_k_type = FieldDescriptorProtoType(nested.field[0].type).name\n                self.proto_v_type = FieldDescriptorProtoType(nested.field[1].type).name\n        super().__post_init__()  # call FieldCompiler-> MessageCompiler __post_init__\n\n    @property\n    def betterproto_field_args(self) -> List[str]:\n        return [f\"betterproto.{self.proto_k_type}\", f\"betterproto.{self.proto_v_type}\"]\n\n    @property\n    def field_type(self) -> str:\n        return \"map\"\n\n    @property\n    def annotation(self) -> str:\n        return self.typing_compiler.dict(self.py_k_type, self.py_v_type)\n\n    @property\n    def repeated(self) -> bool:\n        return False  # maps cannot be repeated\n",
    "methods": [
      {
        "name": "betterproto.plugin.models.MapEntryCompiler.get_field_string",
        "signature": "(self, indent: int = 4) -> str",
        "docstring": "Construct string representation of this field as a field.",
        "source_code": "    def get_field_string(self, indent: int = 4) -> str:\n        \"\"\"Construct string representation of this field as a field.\"\"\"\n        name = f\"{self.py_name}\"\n        annotations = f\": {self.annotation}\"\n        field_args = \", \".join(\n            ([\"\"] + self.betterproto_field_args) if self.betterproto_field_args else []\n        )\n        betterproto_field_type = (\n            f\"betterproto.{self.field_type}_field({self.proto_obj.number}{field_args})\"\n        )\n        if self.py_name in dir(builtins):\n            self.parent.builtins_types.add(self.py_name)\n        return f\"{name}{annotations} = {betterproto_field_type}\"\n"
      }
    ]
  },
  {
    "type": "class",
    "name": "betterproto.plugin.models.OneOfFieldCompiler",
    "signature": "(source_file: betterproto.lib.std.google.protobuf.FileDescriptorProto, typing_compiler: betterproto.plugin.typing_compiler.TypingCompiler, parent: betterproto.plugin.models.MessageCompiler = <object object at 0x101228e80>, proto_obj: betterproto.lib.std.google.protobuf.FieldDescriptorProto = <object object at 0x101228e80>, path: List[int] = <object object at 0x101228e80>, fields: List[Union[ForwardRef('FieldCompiler'), ForwardRef('MessageCompiler')]] = <factory>, builtins_types: Set[str] = <factory>) -> None",
    "docstring": "OneOfFieldCompiler(source_file: betterproto.lib.std.google.protobuf.FileDescriptorProto, typing_compiler: betterproto.plugin.typing_compiler.TypingCompiler, parent: betterproto.plugin.models.MessageCompiler = <object object at 0x101228e80>, proto_obj: betterproto.lib.std.google.protobuf.FieldDescriptorProto = <object object at 0x101228e80>, path: List[int] = <object object at 0x101228e80>, fields: List[Union[ForwardRef('FieldCompiler'), ForwardRef('MessageCompiler')]] = <factory>, builtins_types: Set[str] = <factory>)",
    "source_code": "@dataclass\nclass OneOfFieldCompiler(FieldCompiler):\n    @property\n    def betterproto_field_args(self) -> List[str]:\n        args = super().betterproto_field_args\n        group = self.parent.proto_obj.oneof_decl[self.proto_obj.oneof_index].name\n        args.append(f'group=\"{group}\"')\n        return args\n",
    "methods": [
      {
        "name": "betterproto.plugin.models.OneOfFieldCompiler.get_field_string",
        "signature": "(self, indent: int = 4) -> str",
        "docstring": "Construct string representation of this field as a field.",
        "source_code": "    def get_field_string(self, indent: int = 4) -> str:\n        \"\"\"Construct string representation of this field as a field.\"\"\"\n        name = f\"{self.py_name}\"\n        annotations = f\": {self.annotation}\"\n        field_args = \", \".join(\n            ([\"\"] + self.betterproto_field_args) if self.betterproto_field_args else []\n        )\n        betterproto_field_type = (\n            f\"betterproto.{self.field_type}_field({self.proto_obj.number}{field_args})\"\n        )\n        if self.py_name in dir(builtins):\n            self.parent.builtins_types.add(self.py_name)\n        return f\"{name}{annotations} = {betterproto_field_type}\"\n"
      }
    ]
  },
  {
    "type": "class",
    "name": "betterproto.plugin.models.PydanticOneOfFieldCompiler",
    "signature": "(source_file: betterproto.lib.std.google.protobuf.FileDescriptorProto, typing_compiler: betterproto.plugin.typing_compiler.TypingCompiler, parent: betterproto.plugin.models.MessageCompiler = <object object at 0x101228e80>, proto_obj: betterproto.lib.std.google.protobuf.FieldDescriptorProto = <object object at 0x101228e80>, path: List[int] = <object object at 0x101228e80>, fields: List[Union[ForwardRef('FieldCompiler'), ForwardRef('MessageCompiler')]] = <factory>, builtins_types: Set[str] = <factory>) -> None",
    "docstring": "PydanticOneOfFieldCompiler(source_file: betterproto.lib.std.google.protobuf.FileDescriptorProto, typing_compiler: betterproto.plugin.typing_compiler.TypingCompiler, parent: betterproto.plugin.models.MessageCompiler = <object object at 0x101228e80>, proto_obj: betterproto.lib.std.google.protobuf.FieldDescriptorProto = <object object at 0x101228e80>, path: List[int] = <object object at 0x101228e80>, fields: List[Union[ForwardRef('FieldCompiler'), ForwardRef('MessageCompiler')]] = <factory>, builtins_types: Set[str] = <factory>)",
    "source_code": "@dataclass\nclass PydanticOneOfFieldCompiler(OneOfFieldCompiler):\n    @property\n    def optional(self) -> bool:\n        # Force the optional to be True. This will allow the pydantic dataclass\n        # to validate the object correctly by allowing the field to be let empty.\n        # We add a pydantic validator later to ensure exactly one field is defined.\n        return True\n\n    @property\n    def pydantic_imports(self) -> Set[str]:\n        return {\"model_validator\"}\n",
    "methods": [
      {
        "name": "betterproto.plugin.models.PydanticOneOfFieldCompiler.get_field_string",
        "signature": "(self, indent: int = 4) -> str",
        "docstring": "Construct string representation of this field as a field.",
        "source_code": "    def get_field_string(self, indent: int = 4) -> str:\n        \"\"\"Construct string representation of this field as a field.\"\"\"\n        name = f\"{self.py_name}\"\n        annotations = f\": {self.annotation}\"\n        field_args = \", \".join(\n            ([\"\"] + self.betterproto_field_args) if self.betterproto_field_args else []\n        )\n        betterproto_field_type = (\n            f\"betterproto.{self.field_type}_field({self.proto_obj.number}{field_args})\"\n        )\n        if self.py_name in dir(builtins):\n            self.parent.builtins_types.add(self.py_name)\n        return f\"{name}{annotations} = {betterproto_field_type}\"\n"
      }
    ]
  },
  {
    "type": "function",
    "name": "betterproto.plugin.models.is_map",
    "signature": "(proto_field_obj: betterproto.lib.std.google.protobuf.FieldDescriptorProto, parent_message: betterproto.lib.std.google.protobuf.DescriptorProto) -> bool",
    "docstring": "True if proto_field_obj is a map, otherwise False.",
    "source_code": "def is_map(\n    proto_field_obj: FieldDescriptorProto, parent_message: DescriptorProto\n) -> bool:\n    \"\"\"True if proto_field_obj is a map, otherwise False.\"\"\"\n    if proto_field_obj.type == FieldDescriptorProtoType.TYPE_MESSAGE:\n        if not hasattr(parent_message, \"nested_type\"):\n            return False\n\n        # This might be a map...\n        message_type = proto_field_obj.type_name.split(\".\").pop().lower()\n        map_entry = f\"{proto_field_obj.name.replace('_', '').lower()}entry\"\n        if message_type == map_entry:\n            for nested in parent_message.nested_type:  # parent message\n                if (\n                    nested.name.replace(\"_\", \"\").lower() == map_entry\n                    and nested.options.map_entry\n                ):\n                    return True\n    return False\n",
    "methods": []
  },
  {
    "type": "function",
    "name": "betterproto.plugin.models.is_oneof",
    "signature": "(proto_field_obj: betterproto.lib.std.google.protobuf.FieldDescriptorProto) -> bool",
    "docstring": "True if proto_field_obj is a OneOf, otherwise False.\n\n.. warning::\n    Becuase the message from protoc is defined in proto2, and betterproto works with\n    proto3, and interpreting the FieldDescriptorProto.oneof_index field requires\n    distinguishing between default and unset values (which proto3 doesn't support),\n    we have to hack the generated FieldDescriptorProto class for this to work.\n    The hack consists of setting group=\"oneof_index\" in the field metadata,\n    essentially making oneof_index the sole member of a one_of group, which allows\n    us to tell whether it was set, via the which_one_of interface.",
    "source_code": "def is_oneof(proto_field_obj: FieldDescriptorProto) -> bool:\n    \"\"\"\n    True if proto_field_obj is a OneOf, otherwise False.\n\n    .. warning::\n        Becuase the message from protoc is defined in proto2, and betterproto works with\n        proto3, and interpreting the FieldDescriptorProto.oneof_index field requires\n        distinguishing between default and unset values (which proto3 doesn't support),\n        we have to hack the generated FieldDescriptorProto class for this to work.\n        The hack consists of setting group=\"oneof_index\" in the field metadata,\n        essentially making oneof_index the sole member of a one_of group, which allows\n        us to tell whether it was set, via the which_one_of interface.\n    \"\"\"\n\n    return (\n        not proto_field_obj.proto3_optional\n        and which_one_of(proto_field_obj, \"oneof_index\")[0] == \"oneof_index\"\n    )\n",
    "methods": []
  },
  {
    "type": "function",
    "name": "betterproto.plugin.models.monkey_patch_oneof_index",
    "signature": "()",
    "docstring": "The compiler message types are written for proto2, but we read them as proto3.\nFor this to work in the case of the oneof_index fields, which depend on being able\nto tell whether they were set, we have to treat them as oneof fields. This method\nmonkey patches the generated classes after the fact to force this behaviour.",
    "source_code": "def monkey_patch_oneof_index():\n    \"\"\"\n    The compiler message types are written for proto2, but we read them as proto3.\n    For this to work in the case of the oneof_index fields, which depend on being able\n    to tell whether they were set, we have to treat them as oneof fields. This method\n    monkey patches the generated classes after the fact to force this behaviour.\n    \"\"\"\n    object.__setattr__(\n        FieldDescriptorProto.__dataclass_fields__[\"oneof_index\"].metadata[\n            \"betterproto\"\n        ],\n        \"group\",\n        \"oneof_index\",\n    )\n    object.__setattr__(\n        Field.__dataclass_fields__[\"oneof_index\"].metadata[\"betterproto\"],\n        \"group\",\n        \"oneof_index\",\n    )\n",
    "methods": []
  }
]