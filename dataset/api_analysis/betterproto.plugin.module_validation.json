[
  {
    "type": "class",
    "name": "betterproto.plugin.module_validation.ModuleValidator",
    "signature": "(line_iterator: Iterator[str]) -> None",
    "docstring": "ModuleValidator(line_iterator: Iterator[str])",
    "source_code": "@dataclass\nclass ModuleValidator:\n    line_iterator: Iterator[str]\n    line_number: int = field(init=False, default=0)\n\n    collisions: Dict[str, List[Tuple[int, str]]] = field(\n        init=False, default_factory=lambda: defaultdict(list)\n    )\n\n    def add_import(self, imp: str, number: int, full_line: str):\n        \"\"\"\n        Adds an import to be tracked.\n        \"\"\"\n        self.collisions[imp].append((number, full_line))\n\n    def process_import(self, imp: str):\n        \"\"\"\n        Filters out the import to its actual value.\n        \"\"\"\n        if \" as \" in imp:\n            imp = imp[imp.index(\" as \") + 4 :]\n\n        imp = imp.strip()\n        assert \" \" not in imp, imp\n        return imp\n\n    def evaluate_multiline_import(self, line: str):\n        \"\"\"\n        Evaluates a multiline import from a starting line\n        \"\"\"\n        # Filter the first line and remove anything before the import statement.\n        full_line = line\n        line = line.split(\"import\", 1)[1]\n        if \"(\" in line:\n            conditional = lambda line: \")\" not in line\n        else:\n            conditional = lambda line: \"\\\\\" in line\n\n        # Remove open parenthesis if it exists.\n        if \"(\" in line:\n            line = line[line.index(\"(\") + 1 :]\n\n        # Choose the conditional based on how multiline imports are formatted.\n        while conditional(line):\n            # Split the line by commas\n            imports = line.split(\",\")\n\n            for imp in imports:\n                # Add the import to the namespace\n                imp = self.process_import(imp)\n                if imp:\n                    self.add_import(imp, self.line_number, full_line)\n            # Get the next line\n            full_line = line = next(self.line_iterator)\n            # Increment the line number\n            self.line_number += 1\n\n        # validate the last line\n        if \")\" in line:\n            line = line[: line.index(\")\")]\n        imports = line.split(\",\")\n        for imp in imports:\n            imp = self.process_import(imp)\n            if imp:\n                self.add_import(imp, self.line_number, full_line)\n\n    def evaluate_import(self, line: str):\n        \"\"\"\n        Extracts an import from a line.\n        \"\"\"\n        whole_line = line\n        line = line[line.index(\"import\") + 6 :]\n        values = line.split(\",\")\n        for v in values:\n            self.add_import(self.process_import(v), self.line_number, whole_line)\n\n    def next(self):\n        \"\"\"\n        Evaluate each line for names in the module.\n        \"\"\"\n        line = next(self.line_iterator)\n\n        # Skip lines with indentation or comments\n        if (\n            # Skip indents and whitespace.\n            line.startswith(\" \")\n            or line == \"\\n\"\n            or line.startswith(\"\\t\")\n            or\n            # Skip comments\n            line.startswith(\"#\")\n            or\n            # Skip  decorators\n            line.startswith(\"@\")\n        ):\n            self.line_number += 1\n            return\n\n        # Skip docstrings.\n        if line.startswith('\"\"\"') or line.startswith(\"'''\"):\n            quote = line[0] * 3\n            line = line[3:]\n            while quote not in line:\n                line = next(self.line_iterator)\n            self.line_number += 1\n            return\n\n        # Evaluate Imports.\n        if line.startswith(\"from \") or line.startswith(\"import \"):\n            if \"(\" in line or \"\\\\\" in line:\n                self.evaluate_multiline_import(line)\n            else:\n                self.evaluate_import(line)\n\n        # Evaluate Classes.\n        elif line.startswith(\"class \"):\n            class_name = re.search(r\"class (\\w+)\", line).group(1)\n            if class_name:\n                self.add_import(class_name, self.line_number, line)\n\n        # Evaluate Functions.\n        elif line.startswith(\"def \"):\n            function_name = re.search(r\"def (\\w+)\", line).group(1)\n            if function_name:\n                self.add_import(function_name, self.line_number, line)\n\n        # Evaluate direct assignments.\n        elif \"=\" in line:\n            assignment = re.search(r\"(\\w+)\\s*=\", line).group(1)\n            if assignment:\n                self.add_import(assignment, self.line_number, line)\n\n        self.line_number += 1\n\n    def validate(self) -> bool:\n        \"\"\"\n        Run Validation.\n        \"\"\"\n        try:\n            while True:\n                self.next()\n        except StopIteration:\n            pass\n\n        # Filter collisions for those with more than one value.\n        self.collisions = {k: v for k, v in self.collisions.items() if len(v) > 1}\n\n        # Return True if no collisions are found.\n        return not bool(self.collisions)\n",
    "methods": [
      {
        "name": "betterproto.plugin.module_validation.ModuleValidator.add_import",
        "signature": "(self, imp: str, number: int, full_line: str)",
        "docstring": "Adds an import to be tracked.",
        "source_code": "    def add_import(self, imp: str, number: int, full_line: str):\n        \"\"\"\n        Adds an import to be tracked.\n        \"\"\"\n        self.collisions[imp].append((number, full_line))\n"
      },
      {
        "name": "betterproto.plugin.module_validation.ModuleValidator.evaluate_import",
        "signature": "(self, line: str)",
        "docstring": "Extracts an import from a line.",
        "source_code": "    def evaluate_import(self, line: str):\n        \"\"\"\n        Extracts an import from a line.\n        \"\"\"\n        whole_line = line\n        line = line[line.index(\"import\") + 6 :]\n        values = line.split(\",\")\n        for v in values:\n            self.add_import(self.process_import(v), self.line_number, whole_line)\n"
      },
      {
        "name": "betterproto.plugin.module_validation.ModuleValidator.evaluate_multiline_import",
        "signature": "(self, line: str)",
        "docstring": "Evaluates a multiline import from a starting line",
        "source_code": "    def evaluate_multiline_import(self, line: str):\n        \"\"\"\n        Evaluates a multiline import from a starting line\n        \"\"\"\n        # Filter the first line and remove anything before the import statement.\n        full_line = line\n        line = line.split(\"import\", 1)[1]\n        if \"(\" in line:\n            conditional = lambda line: \")\" not in line\n        else:\n            conditional = lambda line: \"\\\\\" in line\n\n        # Remove open parenthesis if it exists.\n        if \"(\" in line:\n            line = line[line.index(\"(\") + 1 :]\n\n        # Choose the conditional based on how multiline imports are formatted.\n        while conditional(line):\n            # Split the line by commas\n            imports = line.split(\",\")\n\n            for imp in imports:\n                # Add the import to the namespace\n                imp = self.process_import(imp)\n                if imp:\n                    self.add_import(imp, self.line_number, full_line)\n            # Get the next line\n            full_line = line = next(self.line_iterator)\n            # Increment the line number\n            self.line_number += 1\n\n        # validate the last line\n        if \")\" in line:\n            line = line[: line.index(\")\")]\n        imports = line.split(\",\")\n        for imp in imports:\n            imp = self.process_import(imp)\n            if imp:\n                self.add_import(imp, self.line_number, full_line)\n"
      },
      {
        "name": "betterproto.plugin.module_validation.ModuleValidator.process_import",
        "signature": "(self, imp: str)",
        "docstring": "Filters out the import to its actual value.",
        "source_code": "    def process_import(self, imp: str):\n        \"\"\"\n        Filters out the import to its actual value.\n        \"\"\"\n        if \" as \" in imp:\n            imp = imp[imp.index(\" as \") + 4 :]\n\n        imp = imp.strip()\n        assert \" \" not in imp, imp\n        return imp\n"
      },
      {
        "name": "betterproto.plugin.module_validation.ModuleValidator.validate",
        "signature": "(self) -> bool",
        "docstring": "Run Validation.",
        "source_code": "    def validate(self) -> bool:\n        \"\"\"\n        Run Validation.\n        \"\"\"\n        try:\n            while True:\n                self.next()\n        except StopIteration:\n            pass\n\n        # Filter collisions for those with more than one value.\n        self.collisions = {k: v for k, v in self.collisions.items() if len(v) > 1}\n\n        # Return True if no collisions are found.\n        return not bool(self.collisions)\n"
      }
    ]
  }
]